{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,yBAAyB,GAAG,8BAA8B,GAAG,4BAA4B;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;;;;;;;;;AC1FZ;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,oBAAoB,mBAAO,CAAC,mDAAa;AACzC,gBAAgB,mBAAO,CAAC,2CAAS;AACjC,mBAAmB,mBAAO,CAAC,iDAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAe;;;;;;;;;;;ACnHF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+BAA+B;AACxD;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6CAA6C;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAA6C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB,qCAAqC;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA,sDAAsD,cAAc,GAAG,0BAA0B;AACjG;AACA;AACA,sDAAsD,cAAc,GAAG,0BAA0B;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS,UAAU,WAAW,KAAK,wBAAwB,IAAI,aAAa,GAAG,8BAA8B;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;;;;;;;;;;AChTa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,oBAAoB,mBAAO,CAAC,mDAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA,uDAAuD,aAAa;AACpE,kDAAkD,YAAY,IAAI,YAAY;AAC9E;AACA,uEAAuE,gDAAgD;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA,qDAAqD,0CAA0C;AAC/F;AACA,wDAAwD,UAAU;AAClE,iEAAiE,WAAW;AAC5E,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,yEAAyE,UAAU;AACnF,mEAAmE,OAAO;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY,IAAI,cAAc;AACnF;AACA,uEAAuE,gBAAgB;AACvF;AACA;AACA;AACA,kDAAkD,2EAA2E;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,0FAA0F;AAC1F;AACA;AACA,+CAA+C,2BAA2B;AAC1E,sBAAsB;AACtB;AACA;AACA;AACA;AACA,oDAAoD,4BAA4B,IAAI,qBAAqB;AACzG,8DAA8D,sBAAsB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,wEAAwE,cAAc,IAAI,WAAW;AACrG;AACA;AACA,0BAA0B;AAC1B;AACA,wEAAwE,sBAAsB,IAAI,qBAAqB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA,0DAA0D,iEAAiE;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,6CAA6C;AACjG,yCAAyC,wBAAwB;AACjE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,sBAAsB;AACpH,yDAAyD,eAAe;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,2CAA2C;AACzF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,8CAA8C;AACzI,uDAAuD,8CAA8C;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,WAAW,GAAG,aAAa;AACtF;AACA;AACA;AACA,+DAA+D,WAAW,GAAG,YAAY;AACzF;AACA;AACA;AACA,2DAA2D,WAAW,GAAG,YAAY;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,WAAW,GAAG,aAAa;AAC/F;AACA;AACA;AACA,iEAAiE,WAAW,GAAG,YAAY;AAC3F;AACA;AACA;AACA;AACA,+CAA+C,YAAY;AAC3D,iDAAiD,aAAa,GAAG,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU,IAAI,eAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+CAA+C;AACtG;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+CAA+C;AACtG;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,KAAK,WAAW,gBAAgB,MAAM,aAAa;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,KAAK,UAAU,cAAc,cAAc,YAAY;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,aAAa;AAC/E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA,0DAA0D,aAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;UC/7BpB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;AC5Ba;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,kDAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA","sources":["webpack://sequora/./src/client/game/cards.ts","webpack://sequora/./src/client/game/engine.ts","webpack://sequora/./src/client/game/gameLogic.ts","webpack://sequora/./src/client/game/renderer.ts","webpack://sequora/webpack/bootstrap","webpack://sequora/./src/client/index.ts"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.createInitialDeck = exports.createRowFlipCard = exports.createAdjacentFlipCard = exports.createSingleFlipCard = void 0;\r\n/**\r\n * Helper function to flip a token's color\r\n */\r\nfunction flipToken(color) {\r\n    return color === 'R' ? 'B' : 'R';\r\n}\r\n/**\r\n * Single Flip Card - Flips a specific token at the target index\r\n */\r\nfunction createSingleFlipCard(cardId) {\r\n    return {\r\n        id: cardId,\r\n        name: 'Single Flip',\r\n        description: 'Flip one token',\r\n        requiresTarget: true,\r\n        execute: (tokens, targetIndex) => {\r\n            if (targetIndex === undefined || targetIndex < 0 || targetIndex >= tokens.length) {\r\n                return tokens;\r\n            }\r\n            const newTokens = [...tokens];\r\n            newTokens[targetIndex] = flipToken(newTokens[targetIndex]);\r\n            return newTokens;\r\n        }\r\n    };\r\n}\r\nexports.createSingleFlipCard = createSingleFlipCard;\r\n/**\r\n * Adjacent Flip Card - Flips a token and its immediate neighbors\r\n */\r\nfunction createAdjacentFlipCard(cardId) {\r\n    return {\r\n        id: cardId,\r\n        name: 'Adjacent Flip',\r\n        description: 'Flip a token and its neighbors',\r\n        requiresTarget: true,\r\n        execute: (tokens, targetIndex) => {\r\n            if (targetIndex === undefined || targetIndex < 0 || targetIndex >= tokens.length) {\r\n                return tokens;\r\n            }\r\n            const newTokens = [...tokens];\r\n            // Flip left neighbor if exists\r\n            if (targetIndex > 0) {\r\n                newTokens[targetIndex - 1] = flipToken(newTokens[targetIndex - 1]);\r\n            }\r\n            // Flip target token\r\n            newTokens[targetIndex] = flipToken(newTokens[targetIndex]);\r\n            // Flip right neighbor if exists\r\n            if (targetIndex < tokens.length - 1) {\r\n                newTokens[targetIndex + 1] = flipToken(newTokens[targetIndex + 1]);\r\n            }\r\n            return newTokens;\r\n        }\r\n    };\r\n}\r\nexports.createAdjacentFlipCard = createAdjacentFlipCard;\r\n/**\r\n * Row Flip Card - Flips all tokens in the row\r\n */\r\nfunction createRowFlipCard(cardId) {\r\n    return {\r\n        id: cardId,\r\n        name: 'Row Flip',\r\n        description: 'Flip all tokens',\r\n        requiresTarget: false,\r\n        execute: (tokens) => {\r\n            return tokens.map(flipToken);\r\n        }\r\n    };\r\n}\r\nexports.createRowFlipCard = createRowFlipCard;\r\n/**\r\n * Create initial deck of cards\r\n */\r\nfunction createInitialDeck() {\r\n    return [\r\n        createSingleFlipCard('single-1'),\r\n        createSingleFlipCard('single-2'),\r\n        createSingleFlipCard('single-3'),\r\n        createSingleFlipCard('single-4'),\r\n        createAdjacentFlipCard('adjacent-1'),\r\n        createAdjacentFlipCard('adjacent-2'),\r\n        createAdjacentFlipCard('adjacent-3'),\r\n        createRowFlipCard('row-1'),\r\n        createRowFlipCard('row-2'),\r\n        createRowFlipCard('row-3')\r\n    ];\r\n}\r\nexports.createInitialDeck = createInitialDeck;\r\n","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GameEngine = void 0;\r\nconst gameLogic_1 = require(\"./gameLogic\");\r\nconst cards_1 = require(\"./cards\");\r\nconst renderer_1 = require(\"./renderer\");\r\nclass GameEngine {\r\n    constructor() {\r\n        this.selectedCard = null;\r\n        this.gameState = gameLogic_1.GameLogic.createInitialState((0, cards_1.createInitialDeck)());\r\n        this.renderer = new renderer_1.GameRenderer();\r\n        this.initialize();\r\n    }\r\n    initialize() {\r\n        // Set up event listeners\r\n        this.setupEventListeners();\r\n    }\r\n    start() {\r\n        // Initial render\r\n        this.render();\r\n    }\r\n    setupEventListeners() {\r\n        // Delegate click handling to the renderer\r\n        this.renderer.onCardClick = (cardId) => {\r\n            this.handleCardClick(cardId);\r\n        };\r\n        this.renderer.onTokenClick = (tokenIndex) => {\r\n            this.handleTokenClick(tokenIndex);\r\n        };\r\n        this.renderer.onRestartClick = () => {\r\n            this.restart();\r\n        };\r\n    }\r\n    handleCardClick(cardId) {\r\n        if (this.gameState.isGameOver)\r\n            return;\r\n        const card = this.gameState.hand.find(c => c.id === cardId);\r\n        if (!card)\r\n            return;\r\n        if (card.requiresTarget) {\r\n            // Select this card and wait for token selection\r\n            this.selectedCard = card;\r\n            this.renderer.setSelectedCard(card);\r\n            this.render();\r\n        }\r\n        else {\r\n            // Execute card immediately (doesn't require target)\r\n            this.playCard(card);\r\n        }\r\n    }\r\n    handleTokenClick(tokenIndex) {\r\n        if (this.gameState.isGameOver)\r\n            return;\r\n        if (this.selectedCard) {\r\n            // Play the selected card with this token as target\r\n            this.playCard(this.selectedCard, tokenIndex);\r\n            this.selectedCard = null;\r\n            this.renderer.setSelectedCard(null);\r\n        }\r\n    }\r\n    playCard(card, targetIndex) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.gameState = gameLogic_1.GameLogic.playCard(this.gameState, card, targetIndex);\r\n            this.render();\r\n            // Only animate score and show overlay when trial is over\r\n            if (this.gameState.isTrialOver) {\r\n                // Animate the score calculation after rendering and wait for it to complete\r\n                yield this.renderer.animateScore(this.gameState);\r\n                // Show appropriate overlay\r\n                if (this.gameState.isGameOver) {\r\n                    this.renderer.showGameOverOverlay(this.gameState);\r\n                }\r\n                else {\r\n                    // Check if wave is complete (finished all trials in wave)\r\n                    const isWaveComplete = this.gameState.currentTrial >= this.gameState.maxTrials;\r\n                    if (isWaveComplete) {\r\n                        this.renderer.showWaveCompleteOverlay(this.gameState, () => this.startNextTrial());\r\n                    }\r\n                    else {\r\n                        this.renderer.showNextTrialButton(() => this.startNextTrial());\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    restart() {\r\n        this.gameState = gameLogic_1.GameLogic.resetGame((0, cards_1.createInitialDeck)());\r\n        this.selectedCard = null;\r\n        this.renderer.setSelectedCard(null);\r\n        this.renderer.hideNextTrialButton();\r\n        this.renderer.hideWaveCompleteOverlay();\r\n        this.renderer.hideGameOverOverlay();\r\n        this.render();\r\n    }\r\n    startNextTrial() {\r\n        this.gameState = gameLogic_1.GameLogic.startNextTrial(this.gameState, (0, cards_1.createInitialDeck)());\r\n        this.selectedCard = null;\r\n        this.renderer.setSelectedCard(null);\r\n        this.renderer.hideNextTrialButton();\r\n        this.render();\r\n    }\r\n    render() {\r\n        this.renderer.render(this.gameState);\r\n    }\r\n}\r\nexports.GameEngine = GameEngine;\r\nexports.default = GameEngine;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GameLogic = void 0;\r\n/**\r\n * Game Logic - handles game state management and rule enforcement\r\n */\r\nclass GameLogic {\r\n    /**\r\n     * Generate a random color pattern\r\n     */\r\n    static generateRandomPattern() {\r\n        return Array.from({ length: 5 }, () => Math.random() > 0.5 ? 'B' : 'R');\r\n    }\r\n    /**\r\n     * Check if two patterns are the same\r\n     */\r\n    static arePatternsEqual(pattern1, pattern2) {\r\n        return pattern1.every((color, index) => color === pattern2[index]);\r\n    }\r\n    /**\r\n     * Generate starting and target patterns that are different\r\n     */\r\n    static generatePatterns() {\r\n        const target = this.generateRandomPattern();\r\n        let starting = this.generateRandomPattern();\r\n        // Keep generating until we get different patterns\r\n        while (this.arePatternsEqual(starting, target)) {\r\n            starting = this.generateRandomPattern();\r\n        }\r\n        return { starting, target };\r\n    }\r\n    /**\r\n     * Calculate score based on consecutive matching tokens from left to right\r\n     */\r\n    static calculateScore(tokens, targetColors, movesPlayed, minMoves) {\r\n        let score = 0;\r\n        const breakdown = [];\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            if (tokens[i] === targetColors[i]) {\r\n                const points = this.BASE_POINTS * this.MULTIPLIERS[i];\r\n                score += points;\r\n                breakdown.push({\r\n                    slot: i + 1,\r\n                    multiplier: this.MULTIPLIERS[i],\r\n                    points\r\n                });\r\n            }\r\n            else {\r\n                // Stop when we encounter a token that doesn't match\r\n                break;\r\n            }\r\n        }\r\n        // Award bonus if all 5 tokens match AND moves played equals minimum moves\r\n        const bonusEarned = breakdown.length === 5 && movesPlayed === minMoves;\r\n        if (bonusEarned) {\r\n            score += 5; // Bonus: 5 points √ó 1x multiplier\r\n        }\r\n        return { score, breakdown, bonusEarned };\r\n    }\r\n    /**\r\n     * Calculate minimum number of moves to solve puzzle using BFS\r\n     * This is an NP-complete problem, but with small state space we can brute force it\r\n     */\r\n    static calculateMinimumMoves(startTokens, targetTokens, availableCards) {\r\n        // If already solved\r\n        if (this.arePatternsEqual(startTokens, targetTokens)) {\r\n            return 0;\r\n        }\r\n        // BFS to find shortest path\r\n        const queue = [{ tokens: startTokens, moves: 0 }];\r\n        const visited = new Set();\r\n        visited.add(startTokens.join(''));\r\n        const maxMoves = 10; // Reasonable upper bound\r\n        while (queue.length > 0) {\r\n            const current = queue.shift();\r\n            // Don't explore beyond reasonable depth\r\n            if (current.moves >= maxMoves) {\r\n                continue;\r\n            }\r\n            // Try each available card\r\n            for (const card of availableCards) {\r\n                if (card.requiresTarget) {\r\n                    // Try card on each position\r\n                    for (let i = 0; i < current.tokens.length; i++) {\r\n                        const newTokens = card.execute([...current.tokens], i);\r\n                        const stateKey = newTokens.join('');\r\n                        if (this.arePatternsEqual(newTokens, targetTokens)) {\r\n                            return current.moves + 1;\r\n                        }\r\n                        if (!visited.has(stateKey)) {\r\n                            visited.add(stateKey);\r\n                            queue.push({ tokens: newTokens, moves: current.moves + 1 });\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // Card doesn't require target\r\n                    const newTokens = card.execute([...current.tokens]);\r\n                    const stateKey = newTokens.join('');\r\n                    if (this.arePatternsEqual(newTokens, targetTokens)) {\r\n                        return current.moves + 1;\r\n                    }\r\n                    if (!visited.has(stateKey)) {\r\n                        visited.add(stateKey);\r\n                        queue.push({ tokens: newTokens, moves: current.moves + 1 });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // If no solution found within max moves, return max\r\n        return maxMoves;\r\n    }\r\n    /**\r\n     * Play a card and return the new game state\r\n     */\r\n    static playCard(currentState, card, targetIndex) {\r\n        // Don't allow play if game is over\r\n        if (currentState.isGameOver) {\r\n            return currentState;\r\n        }\r\n        // Validate target index for cards that require it\r\n        if (card.requiresTarget && (targetIndex === undefined || targetIndex < 0 || targetIndex >= currentState.tokens.length)) {\r\n            return Object.assign(Object.assign({}, currentState), { message: 'Invalid target selection' });\r\n        }\r\n        // Capture before state for history\r\n        const beforeTokens = [...currentState.tokens];\r\n        // Execute card effect\r\n        const newTokens = card.execute(currentState.tokens, targetIndex);\r\n        // Create history entry\r\n        const historyEntry = {\r\n            cardName: card.name,\r\n            beforeTokens,\r\n            afterTokens: [...newTokens],\r\n            targetIndex\r\n        };\r\n        // Add to history\r\n        const newHistory = [...currentState.playHistory, historyEntry];\r\n        // Remove card from hand\r\n        const newHand = currentState.hand.filter(c => c.id !== card.id);\r\n        // Calculate score and check if target is matched\r\n        const movesPlayed = newHistory.length;\r\n        const { score, breakdown, bonusEarned } = this.calculateScore(newTokens, currentState.targetColors, movesPlayed, currentState.minMovesTarget);\r\n        const isTargetMatched = this.arePatternsEqual(newTokens, currentState.targetColors);\r\n        const isTrialOver = newHand.length === 0 || isTargetMatched;\r\n        // Calculate new wave and total scores\r\n        const newWaveScore = isTrialOver ? currentState.waveScore + score : currentState.waveScore;\r\n        const newTotalScore = isTrialOver ? currentState.totalScore + score : currentState.totalScore;\r\n        // Update trial scores array when trial ends\r\n        const newTrialScores = isTrialOver ? [...currentState.trialScores, score] : currentState.trialScores;\r\n        // Check if wave is complete\r\n        const isWaveComplete = isTrialOver && currentState.currentTrial >= currentState.maxTrials;\r\n        // Update wave scores when wave ends\r\n        const newWaveScores = isWaveComplete ? [...currentState.waveScores, newWaveScore] : currentState.waveScores;\r\n        // Check if game is completely over (all waves completed)\r\n        const isGameOver = isWaveComplete && currentState.currentWave >= currentState.maxWaves;\r\n        let message = '';\r\n        if (isTargetMatched) {\r\n            message = `Perfect! Target matched!`;\r\n        }\r\n        else if (isTrialOver) {\r\n            message = `Trial ${currentState.currentTrial} complete!`;\r\n        }\r\n        else {\r\n            message = `Played ${card.name}`;\r\n        }\r\n        if (isGameOver) {\r\n            if (newTotalScore >= currentState.targetScore) {\r\n                message = `üéâ VICTORY! Final Score: ${newTotalScore}/${currentState.targetScore} - Target Achieved! üéâ`;\r\n            }\r\n            else {\r\n                message = `Game Over - Final Score: ${newTotalScore}/${currentState.targetScore} - Target Not Met`;\r\n            }\r\n        }\r\n        return {\r\n            tokens: newTokens,\r\n            targetColors: currentState.targetColors,\r\n            hand: newHand,\r\n            deck: currentState.deck,\r\n            isGameOver,\r\n            score,\r\n            scoreBreakdown: breakdown,\r\n            message,\r\n            currentTrial: currentState.currentTrial,\r\n            currentWave: currentState.currentWave,\r\n            totalScore: newTotalScore,\r\n            waveScore: newWaveScore,\r\n            maxTrials: currentState.maxTrials,\r\n            maxWaves: currentState.maxWaves,\r\n            targetScore: currentState.targetScore,\r\n            waveTargetScore: currentState.waveTargetScore,\r\n            isTrialOver,\r\n            isTargetMatched,\r\n            playHistory: newHistory,\r\n            trialScores: newTrialScores,\r\n            waveScores: newWaveScores,\r\n            bonusEarned: isTrialOver ? bonusEarned : false,\r\n            minMovesTarget: currentState.minMovesTarget\r\n        };\r\n    }\r\n    /**\r\n     * Deal random cards from deck\r\n     */\r\n    static dealCards(deck, count) {\r\n        // Shuffle deck\r\n        const shuffled = [...deck].sort(() => Math.random() - 0.5);\r\n        const hand = shuffled.slice(0, count);\r\n        const remainingDeck = shuffled.slice(count);\r\n        return { hand, remainingDeck };\r\n    }\r\n    /**\r\n     * Create a new game state with initial configuration\r\n     */\r\n    static createInitialState(fullDeck) {\r\n        const { starting, target } = this.generatePatterns();\r\n        const { hand, remainingDeck } = this.dealCards(fullDeck, 5);\r\n        // Calculate minimum moves needed with the cards in hand\r\n        const minMoves = this.calculateMinimumMoves(starting, target, hand);\r\n        return {\r\n            tokens: starting,\r\n            targetColors: target,\r\n            hand,\r\n            deck: fullDeck,\r\n            isGameOver: false,\r\n            score: 0,\r\n            scoreBreakdown: [],\r\n            message: 'Wave 1, Trial 1 of 3 - Reach 90 points this wave!',\r\n            currentTrial: 1,\r\n            currentWave: 1,\r\n            totalScore: 0,\r\n            waveScore: 0,\r\n            maxTrials: 3,\r\n            maxWaves: 2,\r\n            targetScore: 180,\r\n            waveTargetScore: 90,\r\n            isTrialOver: false,\r\n            isTargetMatched: false,\r\n            playHistory: [],\r\n            trialScores: [],\r\n            waveScores: [],\r\n            bonusEarned: false,\r\n            minMovesTarget: minMoves\r\n        };\r\n    }\r\n    /**\r\n     * Get multipliers array for display\r\n     */\r\n    static getMultipliers() {\r\n        return [...this.MULTIPLIERS];\r\n    }\r\n    /**\r\n     * Reset the game with a new hand dealt from the deck\r\n     */\r\n    static resetGame(fullDeck) {\r\n        return this.createInitialState(fullDeck);\r\n    }\r\n    /**\r\n     * Start the next trial with new patterns and cards\r\n     */\r\n    static startNextTrial(currentState, fullDeck) {\r\n        const { starting, target } = this.generatePatterns();\r\n        const { hand, remainingDeck } = this.dealCards(fullDeck, 5);\r\n        // Determine next trial and wave\r\n        let nextTrial = currentState.currentTrial + 1;\r\n        let nextWave = currentState.currentWave;\r\n        let newWaveScore = currentState.waveScore;\r\n        let newTrialScores = currentState.trialScores;\r\n        // Move to next wave if we've completed all trials in current wave\r\n        if (nextTrial > currentState.maxTrials) {\r\n            nextTrial = 1;\r\n            nextWave++;\r\n            newWaveScore = 0; // Reset wave score for new wave\r\n            newTrialScores = []; // Reset trial scores for new wave\r\n        }\r\n        // Calculate minimum moves for new trial with the cards in hand\r\n        const minMoves = this.calculateMinimumMoves(starting, target, hand);\r\n        return {\r\n            tokens: starting,\r\n            targetColors: target,\r\n            hand,\r\n            deck: fullDeck,\r\n            isGameOver: false,\r\n            score: 0,\r\n            scoreBreakdown: [],\r\n            message: `Wave ${nextWave}, Trial ${nextTrial} of ${currentState.maxTrials} - ${newWaveScore}/${currentState.waveTargetScore} points`,\r\n            currentTrial: nextTrial,\r\n            currentWave: nextWave,\r\n            totalScore: currentState.totalScore,\r\n            waveScore: newWaveScore,\r\n            maxTrials: currentState.maxTrials,\r\n            maxWaves: currentState.maxWaves,\r\n            targetScore: currentState.targetScore,\r\n            waveTargetScore: currentState.waveTargetScore,\r\n            isTrialOver: false,\r\n            isTargetMatched: false,\r\n            playHistory: [],\r\n            trialScores: newTrialScores,\r\n            waveScores: currentState.waveScores,\r\n            bonusEarned: false,\r\n            minMovesTarget: minMoves\r\n        };\r\n    }\r\n}\r\nexports.GameLogic = GameLogic;\r\nGameLogic.MULTIPLIERS = [1, 2, 4, 8, 16];\r\nGameLogic.BASE_POINTS = 1;\r\n","\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GameRenderer = void 0;\r\nconst gameLogic_1 = require(\"./gameLogic\");\r\n/**\r\n * GameRenderer - handles all DOM manipulation and visual updates\r\n */\r\nclass GameRenderer {\r\n    constructor() {\r\n        this.selectedCard = null;\r\n        this.isAnimating = false;\r\n        this.audioContext = null;\r\n        // Event callbacks\r\n        this.onCardClick = () => { };\r\n        this.onTokenClick = () => { };\r\n        this.onRestartClick = () => { };\r\n        this.tokensContainer = this.getOrCreateElement('tokens-container');\r\n        this.targetContainer = this.getOrCreateElement('target-container');\r\n        this.cardsContainer = this.getOrCreateElement('cards-container');\r\n        this.messageElement = this.getOrCreateElement('message');\r\n        this.scoreElement = this.getOrCreateElement('score-display');\r\n        this.totalScoreElement = this.getOrCreateElement('total-score-display');\r\n        this.restartButton = this.getOrCreateElement('restart-button', 'button');\r\n        this.viewDeckButton = this.getOrCreateElement('view-deck-button', 'button');\r\n        this.deckModal = this.getOrCreateElement('deck-modal');\r\n        this.deckCardsContainer = this.getOrCreateElement('deck-cards-container');\r\n        this.closeDeckButton = this.getOrCreateElement('close-deck-button', 'button');\r\n        this.trialInfoElement = this.getOrCreateElement('trial-info');\r\n        this.nextTrialButton = this.getOrCreateElement('next-trial-button', 'button');\r\n        this.trialCompleteOverlay = this.getOrCreateElement('trial-complete-overlay');\r\n        this.waveCompleteOverlay = this.getOrCreateElement('wave-complete-overlay');\r\n        this.historyPanel = this.getOrCreateElement('history-panel');\r\n        this.hamburgerButton = this.getOrCreateElement('hamburger-menu', 'button');\r\n        this.menuDropdown = this.getOrCreateElement('menu-dropdown');\r\n        this.gameOverOverlay = this.getOrCreateElement('game-over-overlay');\r\n        this.multipliers = gameLogic_1.GameLogic.getMultipliers();\r\n        this.setupGameBoard();\r\n        this.setupRestartButton();\r\n        this.setupHamburgerMenu();\r\n        this.setupDeckView();\r\n        this.setupNextTrialButton();\r\n        this.setupTrialCompleteOverlay();\r\n        this.setupWaveCompleteOverlay();\r\n        this.setupGameOverOverlay();\r\n        this.initAudio();\r\n    }\r\n    setupGameBoard() {\r\n        // Create game board wrapper if it doesn't exist\r\n        let gameBoard = document.querySelector('.game-board');\r\n        if (!gameBoard) {\r\n            gameBoard = document.createElement('div');\r\n            gameBoard.className = 'game-board';\r\n            // Create header for integrated info - wave/trial indicators and wave score\r\n            const header = document.createElement('div');\r\n            header.className = 'game-board-header';\r\n            header.appendChild(this.trialInfoElement);\r\n            header.appendChild(this.totalScoreElement);\r\n            gameBoard.appendChild(header);\r\n            // Insert before target container\r\n            const container = document.getElementById('game-container');\r\n            if (container && this.targetContainer.parentNode === container) {\r\n                container.insertBefore(gameBoard, this.targetContainer);\r\n            }\r\n        }\r\n        // Initially hide the score element\r\n        this.scoreElement.style.display = 'none';\r\n    }\r\n    initAudio() {\r\n        // Initialize AudioContext on first user interaction to comply with browser policies\r\n        const initContext = () => {\r\n            if (!this.audioContext) {\r\n                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n            }\r\n            document.removeEventListener('click', initContext);\r\n        };\r\n        document.addEventListener('click', initContext);\r\n    }\r\n    playScoreSound(frequency = 800, duration = 0.1) {\r\n        if (!this.audioContext)\r\n            return;\r\n        const oscillator = this.audioContext.createOscillator();\r\n        const gainNode = this.audioContext.createGain();\r\n        oscillator.connect(gainNode);\r\n        gainNode.connect(this.audioContext.destination);\r\n        oscillator.frequency.value = frequency;\r\n        oscillator.type = 'sine';\r\n        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);\r\n        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);\r\n        oscillator.start(this.audioContext.currentTime);\r\n        oscillator.stop(this.audioContext.currentTime + duration);\r\n    }\r\n    playSkipSound() {\r\n        if (!this.audioContext)\r\n            return;\r\n        const oscillator = this.audioContext.createOscillator();\r\n        const gainNode = this.audioContext.createGain();\r\n        oscillator.connect(gainNode);\r\n        gainNode.connect(this.audioContext.destination);\r\n        oscillator.frequency.value = 200;\r\n        oscillator.type = 'sawtooth';\r\n        gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);\r\n        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);\r\n        oscillator.start(this.audioContext.currentTime);\r\n        oscillator.stop(this.audioContext.currentTime + 0.15);\r\n    }\r\n    playPerfectSound() {\r\n        if (!this.audioContext)\r\n            return;\r\n        const currentTime = this.audioContext.currentTime;\r\n        const duration = 1.5;\r\n        // Create bell-like sound with multiple harmonics at high pitch\r\n        const frequencies = [1400, 1750, 2100, 2800]; // Harmonic series based on final token pitch\r\n        frequencies.forEach((freq, index) => {\r\n            const oscillator = this.audioContext.createOscillator();\r\n            const gainNode = this.audioContext.createGain();\r\n            oscillator.connect(gainNode);\r\n            gainNode.connect(this.audioContext.destination);\r\n            oscillator.frequency.value = freq;\r\n            oscillator.type = 'sine';\r\n            // Each harmonic gets quieter and decays faster\r\n            const volume = 0.3 / (index + 1);\r\n            const decay = duration / (index + 1);\r\n            gainNode.gain.setValueAtTime(volume, currentTime);\r\n            gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + decay);\r\n            oscillator.start(currentTime);\r\n            oscillator.stop(currentTime + duration);\r\n        });\r\n    }\r\n    playBonusSound() {\r\n        if (!this.audioContext)\r\n            return;\r\n        const currentTime = this.audioContext.currentTime;\r\n        const duration = 0.8;\r\n        // Create magical sparkle sound with golden tone\r\n        const frequencies = [800, 1000, 1200, 1600, 2000];\r\n        frequencies.forEach((freq, index) => {\r\n            const oscillator = this.audioContext.createOscillator();\r\n            const gainNode = this.audioContext.createGain();\r\n            oscillator.connect(gainNode);\r\n            gainNode.connect(this.audioContext.destination);\r\n            oscillator.frequency.value = freq;\r\n            oscillator.type = 'sine';\r\n            const delay = index * 0.05;\r\n            const volume = 0.15;\r\n            gainNode.gain.setValueAtTime(0, currentTime + delay);\r\n            gainNode.gain.linearRampToValueAtTime(volume, currentTime + delay + 0.05);\r\n            gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + delay + duration);\r\n            oscillator.start(currentTime + delay);\r\n            oscillator.stop(currentTime + delay + duration);\r\n        });\r\n    }\r\n    getOrCreateElement(id, tagName = 'div') {\r\n        let element = document.getElementById(id);\r\n        if (!element) {\r\n            element = document.createElement(tagName);\r\n            element.id = id;\r\n            document.body.appendChild(element);\r\n        }\r\n        return element;\r\n    }\r\n    setupRestartButton() {\r\n        this.restartButton.textContent = 'Restart Game';\r\n        this.restartButton.addEventListener('click', () => {\r\n            this.isAnimating = false;\r\n            this.scoreElement.classList.remove('final-score');\r\n            this.onRestartClick();\r\n        });\r\n    }\r\n    setupNextTrialButton() {\r\n        this.nextTrialButton.textContent = 'Next Trial';\r\n        this.nextTrialButton.classList.add('hidden');\r\n    }\r\n    setupTrialCompleteOverlay() {\r\n        this.trialCompleteOverlay.classList.add('hidden');\r\n    }\r\n    showNextTrialButton(callback) {\r\n        // This method is kept for compatibility but now shows the overlay\r\n        this.showTrialCompleteOverlay(callback);\r\n    }\r\n    showTrialCompleteOverlay(callback) {\r\n        // Get current game state info from the DOM\r\n        const trialScoreText = this.scoreElement.textContent || 'Trial: 0';\r\n        const trialScore = parseInt(trialScoreText.split(':')[1]) || 0;\r\n        const trialInfoText = this.trialInfoElement.textContent || 'W1 T1/3';\r\n        const waveMatch = trialInfoText.match(/W(\\d+)/);\r\n        const currentWave = waveMatch ? parseInt(waveMatch[1]) : 1;\r\n        const totalScoreText = this.totalScoreElement.textContent || 'Total: 0/180';\r\n        const totalParts = totalScoreText.match(/\\d+/g) || ['0', '180'];\r\n        const totalScore = parseInt(totalParts[0]);\r\n        const targetScore = parseInt(totalParts[1]);\r\n        this.trialCompleteOverlay.innerHTML = `\r\n            <div class=\"trial-complete-content\">\r\n                <h2>Trial Complete!</h2>\r\n                <div class=\"trial-stats\">\r\n                    <div class=\"stat-item trial-earned\">\r\n                        <div class=\"stat-label\">Score Earned</div>\r\n                        <div class=\"stat-value\">+${trialScore}</div>\r\n                    </div>\r\n                    <div class=\"stat-item total-progress\">\r\n                        <div class=\"stat-label\">Wave ${currentWave} Progress</div>\r\n                        <div class=\"stat-value\">${totalScore} / ${targetScore}</div>\r\n                        <div class=\"progress-bar-large\">\r\n                            <div class=\"progress-fill\" style=\"width: ${Math.min(100, (totalScore / targetScore) * 100)}%\"></div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n                <button class=\"continue-button\">Continue to Next Trial</button>\r\n            </div>\r\n        `;\r\n        this.trialCompleteOverlay.classList.remove('hidden');\r\n        // Add click handler to continue button\r\n        const continueButton = this.trialCompleteOverlay.querySelector('.continue-button');\r\n        if (continueButton) {\r\n            continueButton.addEventListener('click', () => {\r\n                this.hideTrialCompleteOverlay();\r\n                callback();\r\n            });\r\n        }\r\n    }\r\n    hideNextTrialButton() {\r\n        this.nextTrialButton.classList.add('hidden');\r\n        this.hideTrialCompleteOverlay();\r\n    }\r\n    hideTrialCompleteOverlay() {\r\n        this.trialCompleteOverlay.classList.add('hidden');\r\n    }\r\n    setupWaveCompleteOverlay() {\r\n        this.waveCompleteOverlay.classList.add('hidden');\r\n    }\r\n    showWaveCompleteOverlay(gameState, callback) {\r\n        const waveNumber = gameState.currentWave;\r\n        const waveScore = gameState.waveScore;\r\n        const waveTarget = gameState.waveTargetScore;\r\n        const totalScore = gameState.totalScore;\r\n        const overallTarget = gameState.targetScore;\r\n        const progressPercent = Math.min(100, (totalScore / overallTarget) * 100);\r\n        const waveMet = waveScore >= waveTarget;\r\n        this.waveCompleteOverlay.innerHTML = `\r\n            <div class=\"wave-complete-content\">\r\n                <h2>üåä Wave ${waveNumber} Complete! üåä</h2>\r\n                <div class=\"wave-summary\">\r\n                    <div class=\"wave-score-display ${waveMet ? 'wave-success' : 'wave-partial'}\">\r\n                        <div class=\"wave-score-label\">Wave Score</div>\r\n                        <div class=\"wave-score-value\">${waveScore}</div>\r\n                        <div class=\"wave-score-target\">Target: ${waveTarget}</div>\r\n                        ${waveMet ? '<div class=\"wave-badge\">‚ú® Target Met! ‚ú®</div>' : '<div class=\"wave-badge-miss\">Keep Going!</div>'}\r\n                    </div>\r\n                    \r\n                    <div class=\"trial-results\">\r\n                        <div class=\"trial-results-header\">Trial Results</div>\r\n                        ${gameState.trialScores.map((score, index) => `\r\n                            <div class=\"trial-result-item\">\r\n                                <span class=\"trial-result-label\">Trial ${index + 1}</span>\r\n                                <span class=\"trial-result-score\">${score} pts</span>\r\n                            </div>\r\n                        `).join('')}\r\n                    </div>\r\n                    \r\n                    <div class=\"overall-progress\">\r\n                        <div class=\"overall-label\">Overall Progress</div>\r\n                        <div class=\"overall-value\">${totalScore} / ${overallTarget}</div>\r\n                        <div class=\"progress-bar-large\">\r\n                            <div class=\"progress-fill\" style=\"width: ${progressPercent}%\"></div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n                <button class=\"continue-button\">${waveNumber < gameState.maxWaves ? 'Continue to Next Wave' : 'View Results'}</button>\r\n            </div>\r\n        `;\r\n        this.waveCompleteOverlay.classList.remove('hidden');\r\n        // Add click handler to continue button\r\n        const continueButton = this.waveCompleteOverlay.querySelector('.continue-button');\r\n        if (continueButton) {\r\n            continueButton.addEventListener('click', () => {\r\n                this.hideWaveCompleteOverlay();\r\n                callback();\r\n            });\r\n        }\r\n    }\r\n    hideWaveCompleteOverlay() {\r\n        this.waveCompleteOverlay.classList.add('hidden');\r\n    }\r\n    setupGameOverOverlay() {\r\n        this.gameOverOverlay.classList.add('hidden');\r\n    }\r\n    showGameOverOverlay(gameState) {\r\n        const won = gameState.totalScore >= gameState.targetScore;\r\n        const totalCards = gameState.trialScores.length * 5; // 5 cards per trial\r\n        const bestTrial = gameState.trialScores.length > 0 ? Math.max(...gameState.trialScores) : 0;\r\n        const perfectTrials = gameState.trialScores.filter(score => score === 31).length; // Max score is 31 (1+2+4+8+16)\r\n        this.gameOverOverlay.innerHTML = `\r\n            <div class=\"game-over-content\">\r\n                <div class=\"game-over-header ${won ? 'victory' : 'defeat'}\">\r\n                    ${won ? 'üèÜ VICTORY! üèÜ' : 'üíî GAME OVER üíî'}\r\n                </div>\r\n                \r\n                <div class=\"final-score-display\">\r\n                    <div class=\"final-score-label\">Final Score</div>\r\n                    <div class=\"final-score-value ${won ? 'success' : 'failure'}\">${gameState.totalScore}</div>\r\n                    <div class=\"final-score-target\">Target: ${gameState.targetScore}</div>\r\n                </div>\r\n                \r\n                <div class=\"game-stats\">\r\n                    <div class=\"stats-header\">Game Summary</div>\r\n                    \r\n                    <div class=\"wave-summary-section\">\r\n                        ${gameState.waveScores.map((waveScore, waveIndex) => `\r\n                            <div class=\"wave-summary-item\">\r\n                                <div class=\"wave-summary-header\">Wave ${waveIndex + 1}: ${waveScore} pts</div>\r\n                            </div>\r\n                        `).join('')}\r\n                        ${gameState.currentWave <= gameState.maxWaves && gameState.trialScores.length > 0 ? `\r\n                            <div class=\"wave-summary-item current-wave\">\r\n                                <div class=\"wave-summary-header\">Wave ${gameState.currentWave}: ${gameState.waveScore} pts</div>\r\n                            </div>\r\n                        ` : ''}\r\n                    </div>\r\n                    \r\n                    <div class=\"additional-stats\">\r\n                        <div class=\"stat-box\">\r\n                            <div class=\"stat-box-value\">${totalCards}</div>\r\n                            <div class=\"stat-box-label\">Cards Played</div>\r\n                        </div>\r\n                        <div class=\"stat-box\">\r\n                            <div class=\"stat-box-value\">${perfectTrials}</div>\r\n                            <div class=\"stat-box-label\">Perfect Trials</div>\r\n                        </div>\r\n                        <div class=\"stat-box\">\r\n                            <div class=\"stat-box-value\">${Math.round((gameState.totalScore / gameState.targetScore) * 100)}%</div>\r\n                            <div class=\"stat-box-label\">Target Reached</div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n                \r\n                <button class=\"play-again-button\">Play Again</button>\r\n            </div>\r\n        `;\r\n        this.gameOverOverlay.classList.remove('hidden');\r\n        // Add click handler to play again button\r\n        const playAgainButton = this.gameOverOverlay.querySelector('.play-again-button');\r\n        if (playAgainButton) {\r\n            playAgainButton.addEventListener('click', () => {\r\n                this.hideGameOverOverlay();\r\n                this.onRestartClick();\r\n            });\r\n        }\r\n    }\r\n    hideGameOverOverlay() {\r\n        this.gameOverOverlay.classList.add('hidden');\r\n    }\r\n    setupHamburgerMenu() {\r\n        var _a;\r\n        // Setup hamburger button\r\n        this.hamburgerButton.innerHTML = '‚ò∞';\r\n        this.hamburgerButton.className = 'hamburger-menu';\r\n        // Position it inside the game header to the left of the logo\r\n        const gameHeader = document.querySelector('.game-header');\r\n        if (gameHeader) {\r\n            gameHeader.insertBefore(this.hamburgerButton, gameHeader.firstChild);\r\n        }\r\n        // Setup menu dropdown\r\n        this.menuDropdown.className = 'menu-dropdown hidden';\r\n        this.menuDropdown.innerHTML = `\r\n            <div class=\"menu-item\" data-action=\"view-deck\">View Deck</div>\r\n            <div class=\"menu-item\" data-action=\"toggle-logo\">Switch Logo Theme</div>\r\n            <div class=\"menu-item\" data-action=\"quit\">Quit</div>\r\n        `;\r\n        // Insert menu dropdown after hamburger\r\n        (_a = this.hamburgerButton.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(this.menuDropdown);\r\n        // Apply saved logo theme\r\n        this.applyLogoTheme();\r\n        // Toggle menu on hamburger click\r\n        this.hamburgerButton.addEventListener('click', (e) => {\r\n            e.stopPropagation();\r\n            this.menuDropdown.classList.toggle('hidden');\r\n        });\r\n        // Handle menu item clicks\r\n        this.menuDropdown.addEventListener('click', (e) => {\r\n            const target = e.target;\r\n            if (target.classList.contains('menu-item')) {\r\n                const action = target.dataset.action;\r\n                if (action === 'view-deck') {\r\n                    this.showDeckModal();\r\n                }\r\n                else if (action === 'toggle-logo') {\r\n                    this.toggleLogoTheme();\r\n                }\r\n                else if (action === 'quit') {\r\n                    // Return to start screen\r\n                    const gameContainer = document.getElementById('game-container');\r\n                    const startScreen = document.getElementById('start-screen');\r\n                    if (gameContainer && startScreen) {\r\n                        gameContainer.classList.add('hidden');\r\n                        startScreen.classList.remove('hidden');\r\n                        // Reload the page to reset game state\r\n                        setTimeout(() => {\r\n                            window.location.reload();\r\n                        }, 100);\r\n                    }\r\n                }\r\n                this.menuDropdown.classList.add('hidden');\r\n            }\r\n        });\r\n        // Close menu when clicking outside\r\n        document.addEventListener('click', () => {\r\n            this.menuDropdown.classList.add('hidden');\r\n        });\r\n    }\r\n    toggleLogoTheme() {\r\n        const currentTheme = localStorage.getItem('logoTheme') || 'black';\r\n        const newTheme = currentTheme === 'black' ? 'white' : 'black';\r\n        localStorage.setItem('logoTheme', newTheme);\r\n        this.applyLogoTheme();\r\n    }\r\n    applyLogoTheme() {\r\n        const theme = localStorage.getItem('logoTheme') || 'black';\r\n        const gameLogo = document.querySelector('.game-logo');\r\n        const gameHeader = document.querySelector('.game-header');\r\n        const gameBoardHeader = document.querySelector('.game-board-header');\r\n        if (gameLogo && gameHeader) {\r\n            if (theme === 'white') {\r\n                gameLogo.src = 'images/sequora_white.png';\r\n                gameHeader.classList.add('white-theme');\r\n                gameHeader.classList.remove('black-theme');\r\n                if (gameBoardHeader) {\r\n                    gameBoardHeader.classList.add('white-theme');\r\n                    gameBoardHeader.classList.remove('black-theme');\r\n                }\r\n            }\r\n            else {\r\n                gameLogo.src = 'images/sequora_black.png';\r\n                gameHeader.classList.add('black-theme');\r\n                gameHeader.classList.remove('white-theme');\r\n                if (gameBoardHeader) {\r\n                    gameBoardHeader.classList.add('black-theme');\r\n                    gameBoardHeader.classList.remove('white-theme');\r\n                }\r\n            }\r\n        }\r\n    }\r\n    setupDeckView() {\r\n        this.viewDeckButton.textContent = 'View Deck';\r\n        this.viewDeckButton.addEventListener('click', () => {\r\n            this.showDeckModal();\r\n        });\r\n        this.closeDeckButton.addEventListener('click', () => {\r\n            this.hideDeckModal();\r\n        });\r\n        // Close modal when clicking outside the content\r\n        this.deckModal.addEventListener('click', (e) => {\r\n            if (e.target === this.deckModal) {\r\n                this.hideDeckModal();\r\n            }\r\n        });\r\n    }\r\n    showDeckModal() {\r\n        this.deckModal.classList.remove('hidden');\r\n    }\r\n    hideDeckModal() {\r\n        this.deckModal.classList.add('hidden');\r\n    }\r\n    renderDeck(deck, currentHand) {\r\n        this.deckCardsContainer.innerHTML = '';\r\n        deck.forEach((card) => {\r\n            const cardElement = document.createElement('div');\r\n            cardElement.className = 'deck-card';\r\n            // Mark cards that are currently in hand\r\n            const isInHand = currentHand.some(c => c.id === card.id);\r\n            if (isInHand) {\r\n                cardElement.classList.add('in-hand');\r\n            }\r\n            const cardName = document.createElement('div');\r\n            cardName.className = 'deck-card-name';\r\n            cardName.textContent = card.name;\r\n            const cardDescription = document.createElement('div');\r\n            cardDescription.className = 'deck-card-description';\r\n            cardDescription.textContent = card.description;\r\n            cardElement.appendChild(cardName);\r\n            cardElement.appendChild(cardDescription);\r\n            this.deckCardsContainer.appendChild(cardElement);\r\n        });\r\n    }\r\n    setSelectedCard(card) {\r\n        this.selectedCard = card;\r\n    }\r\n    renderTargetColors(targetColors, minMovesTarget) {\r\n        // Ensure target container is in game board\r\n        const gameBoard = document.querySelector('.game-board');\r\n        if (gameBoard && this.targetContainer.parentNode !== gameBoard) {\r\n            gameBoard.appendChild(this.targetContainer);\r\n        }\r\n        this.targetContainer.innerHTML = '<div class=\"target-label\">Target:</div>';\r\n        targetColors.forEach((color, index) => {\r\n            const targetToken = document.createElement('div');\r\n            targetToken.className = `target-token ${color === 'R' ? 'target-red' : 'target-blue'}`;\r\n            targetToken.textContent = `${this.multipliers[index]}x`;\r\n            this.targetContainer.appendChild(targetToken);\r\n        });\r\n        // Add separator\r\n        const separator = document.createElement('div');\r\n        separator.className = 'token-separator';\r\n        this.targetContainer.appendChild(separator);\r\n        // Add bonus target token (golden)\r\n        const bonusTargetToken = document.createElement('div');\r\n        bonusTargetToken.className = 'target-token target-bonus';\r\n        bonusTargetToken.textContent = '1x';\r\n        this.targetContainer.appendChild(bonusTargetToken);\r\n        // Add separator\r\n        const separator2 = document.createElement('div');\r\n        separator2.className = 'token-separator';\r\n        this.targetContainer.appendChild(separator2);\r\n        // Add minimum moves target (card icon)\r\n        const minMovesToken = document.createElement('div');\r\n        minMovesToken.className = 'target-token target-moves';\r\n        minMovesToken.innerHTML = `<div class=\"moves-icon\">üé¥</div><div class=\"moves-count\">${minMovesTarget || '?'}</div>`;\r\n        minMovesToken.title = `Minimum moves to solve: ${minMovesTarget}`;\r\n        this.targetContainer.appendChild(minMovesToken);\r\n    }\r\n    render(gameState) {\r\n        this.renderTargetColors(gameState.targetColors, gameState.minMovesTarget);\r\n        this.renderTokens(gameState.tokens, gameState.playHistory.length);\r\n        this.renderCards(gameState.hand);\r\n        this.renderHistory(gameState.playHistory);\r\n        // Only show score during trial end, otherwise show 0 or \"-\"\r\n        if (gameState.isTrialOver) {\r\n            this.renderScore(gameState.score);\r\n        }\r\n        else {\r\n            this.renderScore(0);\r\n        }\r\n        // Always show wave score in score display area\r\n        this.renderTotalScore(gameState.waveScore, gameState.waveTargetScore, false);\r\n        this.renderTrialInfo(gameState.currentTrial, gameState.currentWave, gameState.maxTrials, gameState.waveScore, gameState.waveTargetScore);\r\n        this.renderMessage(gameState.message, gameState.isGameOver);\r\n        this.renderDeck(gameState.deck, gameState.hand);\r\n    }\r\n    animateScore(gameState) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.isAnimating)\r\n                return;\r\n            this.isAnimating = true;\r\n            // Show trial score element and add it to header during animation\r\n            const header = document.querySelector('.game-board-header');\r\n            if (header && !header.contains(this.scoreElement)) {\r\n                // Insert trial score between trial info and wave score\r\n                header.insertBefore(this.scoreElement, this.totalScoreElement);\r\n            }\r\n            this.scoreElement.style.display = 'block';\r\n            this.scoreElement.textContent = 'Score: 0';\r\n            yield this.animateScoreCalculation(gameState.tokens, gameState.scoreBreakdown, gameState.targetColors, gameState.bonusEarned);\r\n            // Hide trial score after animation\r\n            yield this.delay(500);\r\n            this.scoreElement.style.display = 'none';\r\n            // After animation completes, if game is over, show final score\r\n            if (gameState.isGameOver) {\r\n                this.renderTotalScore(gameState.totalScore, gameState.targetScore, true);\r\n            }\r\n            this.isAnimating = false;\r\n        });\r\n    }\r\n    renderTokens(tokens, currentMoves) {\r\n        // Ensure tokens container is in game board\r\n        const gameBoard = document.querySelector('.game-board');\r\n        if (gameBoard && this.tokensContainer.parentNode !== gameBoard) {\r\n            gameBoard.appendChild(this.tokensContainer);\r\n        }\r\n        this.tokensContainer.innerHTML = '';\r\n        tokens.forEach((token, index) => {\r\n            var _a;\r\n            const tokenWrapper = document.createElement('div');\r\n            tokenWrapper.className = 'token-wrapper';\r\n            // Token element with point value in center\r\n            const tokenElement = document.createElement('div');\r\n            tokenElement.className = `token ${token === 'R' ? 'token-red' : 'token-blue'}`;\r\n            tokenElement.dataset.index = index.toString();\r\n            tokenElement.textContent = '1';\r\n            // Add click handler\r\n            tokenElement.addEventListener('click', () => {\r\n                this.onTokenClick(index);\r\n            });\r\n            // Add hover effect if a card requiring target is selected\r\n            if ((_a = this.selectedCard) === null || _a === void 0 ? void 0 : _a.requiresTarget) {\r\n                tokenElement.classList.add('selectable');\r\n            }\r\n            tokenWrapper.appendChild(tokenElement);\r\n            this.tokensContainer.appendChild(tokenWrapper);\r\n        });\r\n        // Add separator\r\n        const separator = document.createElement('div');\r\n        separator.className = 'token-separator';\r\n        this.tokensContainer.appendChild(separator);\r\n        // Add bonus token (golden)\r\n        const bonusWrapper = document.createElement('div');\r\n        bonusWrapper.className = 'token-wrapper';\r\n        const bonusToken = document.createElement('div');\r\n        bonusToken.className = 'token token-bonus';\r\n        bonusToken.textContent = '5';\r\n        bonusToken.dataset.index = 'bonus';\r\n        bonusWrapper.appendChild(bonusToken);\r\n        this.tokensContainer.appendChild(bonusWrapper);\r\n        // Add separator\r\n        const separator2 = document.createElement('div');\r\n        separator2.className = 'token-separator';\r\n        this.tokensContainer.appendChild(separator2);\r\n        // Add current moves counter (card icon)\r\n        const movesWrapper = document.createElement('div');\r\n        movesWrapper.className = 'token-wrapper';\r\n        const movesToken = document.createElement('div');\r\n        movesToken.className = 'token token-moves';\r\n        movesToken.innerHTML = `<div class=\"moves-icon\">üé¥</div><div class=\"moves-count\">${currentMoves !== undefined ? currentMoves : 0}</div>`;\r\n        movesToken.title = `Cards played this trial: ${currentMoves !== undefined ? currentMoves : 0}`;\r\n        movesWrapper.appendChild(movesToken);\r\n        this.tokensContainer.appendChild(movesWrapper);\r\n    }\r\n    renderCards(hand) {\r\n        this.cardsContainer.innerHTML = '';\r\n        if (hand.length === 0) {\r\n            const emptyMessage = document.createElement('div');\r\n            emptyMessage.className = 'empty-hand-message';\r\n            emptyMessage.textContent = 'No cards remaining';\r\n            this.cardsContainer.appendChild(emptyMessage);\r\n            return;\r\n        }\r\n        hand.forEach((card) => {\r\n            var _a;\r\n            const cardElement = document.createElement('div');\r\n            cardElement.className = 'card';\r\n            cardElement.dataset.cardId = card.id;\r\n            // Highlight selected card\r\n            if (((_a = this.selectedCard) === null || _a === void 0 ? void 0 : _a.id) === card.id) {\r\n                cardElement.classList.add('selected');\r\n            }\r\n            // Add icon based on card type\r\n            const cardIcon = document.createElement('div');\r\n            cardIcon.className = 'card-icon';\r\n            if (card.name === 'Single Flip') {\r\n                cardIcon.classList.add('icon-single-flip');\r\n            }\r\n            else if (card.name === 'Adjacent Flip') {\r\n                cardIcon.classList.add('icon-adjacent-flip');\r\n            }\r\n            else if (card.name === 'Row Flip') {\r\n                cardIcon.classList.add('icon-row-flip');\r\n            }\r\n            const cardName = document.createElement('div');\r\n            cardName.className = 'card-name';\r\n            cardName.textContent = card.name;\r\n            const cardDescription = document.createElement('div');\r\n            cardDescription.className = 'card-description';\r\n            cardDescription.textContent = card.description;\r\n            cardElement.appendChild(cardIcon);\r\n            cardElement.appendChild(cardName);\r\n            cardElement.appendChild(cardDescription);\r\n            // Add click handler\r\n            cardElement.addEventListener('click', () => {\r\n                this.onCardClick(card.id);\r\n            });\r\n            this.cardsContainer.appendChild(cardElement);\r\n        });\r\n    }\r\n    renderMessage(message, isGameOver) {\r\n        this.messageElement.textContent = message;\r\n        this.messageElement.className = 'message';\r\n        if (isGameOver) {\r\n            if (message.includes('VICTORY')) {\r\n                this.messageElement.classList.add('victory');\r\n            }\r\n            else {\r\n                this.messageElement.classList.add('game-over');\r\n            }\r\n        }\r\n    }\r\n    renderScore(score) {\r\n        this.scoreElement.textContent = `Score: ${score}`;\r\n    }\r\n    renderTotalScore(totalScore, targetScore, isGameOver) {\r\n        this.totalScoreElement.classList.remove('final-score', 'target-met', 'target-missed');\r\n        if (isGameOver) {\r\n            this.totalScoreElement.classList.add('final-score');\r\n            const targetMet = totalScore >= targetScore;\r\n            if (targetMet) {\r\n                this.totalScoreElement.classList.add('target-met');\r\n                this.totalScoreElement.textContent = `üèÜ ${totalScore}/${targetScore} üèÜ`;\r\n            }\r\n            else {\r\n                this.totalScoreElement.classList.add('target-missed');\r\n                this.totalScoreElement.textContent = `Final: ${totalScore}/${targetScore}`;\r\n            }\r\n        }\r\n        else {\r\n            this.totalScoreElement.textContent = `Score: ${totalScore}/${targetScore}`;\r\n        }\r\n    }\r\n    renderFinalScore(totalScore, targetScore, targetMet) {\r\n        this.totalScoreElement.classList.add('final-score');\r\n        if (targetMet) {\r\n            this.totalScoreElement.classList.add('target-met');\r\n            this.totalScoreElement.textContent = `üèÜ Final Score: ${totalScore}/${targetScore} üèÜ`;\r\n        }\r\n        else {\r\n            this.totalScoreElement.classList.add('target-missed');\r\n            this.totalScoreElement.textContent = `Final Score: ${totalScore}/${targetScore}`;\r\n        }\r\n    }\r\n    renderTrialInfo(currentTrial, currentWave, maxTrials, waveScore, waveTargetScore) {\r\n        this.trialInfoElement.innerHTML = `\r\n            <div class=\"wave-indicator\">Wave ${currentWave}</div>\r\n            <div class=\"trial-indicator\">Trial ${currentTrial}/${maxTrials}</div>\r\n        `;\r\n    }\r\n    renderHistory(playHistory) {\r\n        this.historyPanel.innerHTML = '<div class=\"history-header\">Play History</div>';\r\n        if (playHistory.length === 0) {\r\n            this.historyPanel.innerHTML += '<div class=\"history-empty\">No cards played yet</div>';\r\n            return;\r\n        }\r\n        // Render in chronological order (most recent last)\r\n        playHistory.forEach((entry, index) => {\r\n            const historyItem = document.createElement('div');\r\n            historyItem.className = 'history-item';\r\n            const cardName = document.createElement('div');\r\n            cardName.className = 'history-card-name';\r\n            cardName.textContent = `${index + 1}. ${entry.cardName}`;\r\n            const tokensRow = document.createElement('div');\r\n            tokensRow.className = 'history-tokens-row';\r\n            // Before tokens\r\n            const beforeDiv = document.createElement('div');\r\n            beforeDiv.className = 'history-tokens';\r\n            entry.beforeTokens.forEach(token => {\r\n                const tokenSpan = document.createElement('span');\r\n                tokenSpan.className = `history-token ${token === 'R' ? 'history-red' : 'history-blue'}`;\r\n                beforeDiv.appendChild(tokenSpan);\r\n            });\r\n            // Arrow\r\n            const arrow = document.createElement('div');\r\n            arrow.className = 'history-arrow';\r\n            arrow.textContent = '‚Üí';\r\n            // After tokens\r\n            const afterDiv = document.createElement('div');\r\n            afterDiv.className = 'history-tokens';\r\n            entry.afterTokens.forEach(token => {\r\n                const tokenSpan = document.createElement('span');\r\n                tokenSpan.className = `history-token ${token === 'R' ? 'history-red' : 'history-blue'}`;\r\n                afterDiv.appendChild(tokenSpan);\r\n            });\r\n            tokensRow.appendChild(beforeDiv);\r\n            tokensRow.appendChild(arrow);\r\n            tokensRow.appendChild(afterDiv);\r\n            historyItem.appendChild(cardName);\r\n            historyItem.appendChild(tokensRow);\r\n            this.historyPanel.appendChild(historyItem);\r\n        });\r\n    }\r\n    animateScoreCalculation(tokens, breakdown, targetColors, bonusEarned) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Wait a moment before starting animation\r\n            yield this.delay(150);\r\n            let runningTotal = 0;\r\n            const scoredSlots = new Set(breakdown.map(b => b.slot));\r\n            let canScore = true; // Track if we can still score tokens\r\n            // Go through each token slot\r\n            for (let i = 0; i < tokens.length; i++) {\r\n                const slot = i + 1;\r\n                // Highlight the current token and target token\r\n                this.highlightToken(i);\r\n                this.highlightTargetToken(i);\r\n                if (scoredSlots.has(slot) && canScore) {\r\n                    // This token scored\r\n                    const item = breakdown.find(b => b.slot === slot);\r\n                    // Play scoring sound with dramatic pitch increase (250Hz jumps)\r\n                    this.playScoreSound(400 + (i * 250), 0.15);\r\n                    // Show calculation\r\n                    this.messageElement.textContent = `Slot ${slot}: 1 pt √ó ${item.multiplier}x = ${item.points} pts`;\r\n                    // Animate score increment with token-specific pitch\r\n                    yield this.animateScoreIncrement(runningTotal, runningTotal + item.points, i);\r\n                    runningTotal += item.points;\r\n                    yield this.delay(300);\r\n                    this.removeTokenHighlight(i);\r\n                    this.removeTargetTokenHighlight(i);\r\n                }\r\n                else {\r\n                    // This token doesn't score - show skip\r\n                    this.playSkipSound();\r\n                    const currentColor = tokens[i] === 'R' ? 'red' : 'blue';\r\n                    const targetColor = targetColors[i] === 'R' ? 'red' : 'blue';\r\n                    this.messageElement.textContent = `Slot ${slot}: SKIP (${currentColor} token, need ${targetColor})`;\r\n                    this.showSkipIndicator(i);\r\n                    this.showTargetSkipIndicator(i);\r\n                    yield this.delay(300);\r\n                    // Mark that we can't score any more tokens after this\r\n                    canScore = false;\r\n                    this.removeTokenHighlight(i);\r\n                    this.removeTargetTokenHighlight(i);\r\n                }\r\n            }\r\n            // Animate bonus if earned\r\n            if (bonusEarned) {\r\n                this.highlightBonusToken();\r\n                this.highlightBonusTargetToken();\r\n                // Play special bonus sound\r\n                this.playBonusSound();\r\n                // Show bonus calculation\r\n                this.messageElement.textContent = 'üåü BONUS: 5 pts √ó 1x = 5 pts üåü';\r\n                // Animate bonus score increment\r\n                yield this.animateScoreIncrement(runningTotal, runningTotal + 5, -1);\r\n                runningTotal += 5;\r\n                yield this.delay(400);\r\n                this.removeBonusHighlight();\r\n                this.removeBonusTargetHighlight();\r\n            }\r\n            else {\r\n                // Show bonus as missed\r\n                this.showBonusSkipIndicator();\r\n                this.showBonusTargetSkipIndicator();\r\n                // Play skip sound\r\n                this.playSkipSound();\r\n                // Show missed bonus message\r\n                this.messageElement.textContent = 'BONUS: MISSED (not all tokens match)';\r\n                yield this.delay(400);\r\n                this.removeBonusSkipIndicator();\r\n                this.removeBonusTargetSkipIndicator();\r\n            }\r\n            // Brief pause before returning to normal message\r\n            yield this.delay(150);\r\n            if (breakdown.length === 5) {\r\n                this.playPerfectSound();\r\n                this.messageElement.textContent = bonusEarned ? 'üéâ PERFECT! Bonus earned! üéâ' : 'üéâ PERFECT! Target matched! üéâ';\r\n            }\r\n            else {\r\n                this.messageElement.textContent = `Trial Score: ${runningTotal}`;\r\n            }\r\n        });\r\n    }\r\n    highlightToken(index) {\r\n        const tokenWrappers = this.tokensContainer.querySelectorAll('.token-wrapper');\r\n        if (tokenWrappers[index]) {\r\n            tokenWrappers[index].classList.add('scoring');\r\n        }\r\n    }\r\n    removeTokenHighlight(index) {\r\n        const tokenWrappers = this.tokensContainer.querySelectorAll('.token-wrapper');\r\n        if (tokenWrappers[index]) {\r\n            tokenWrappers[index].classList.remove('scoring');\r\n            tokenWrappers[index].classList.remove('skipped');\r\n        }\r\n    }\r\n    highlightBonusToken() {\r\n        var _a;\r\n        const bonusToken = this.tokensContainer.querySelector('.token-bonus');\r\n        if (bonusToken) {\r\n            (_a = bonusToken.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('scoring');\r\n        }\r\n    }\r\n    removeBonusHighlight() {\r\n        var _a;\r\n        const bonusToken = this.tokensContainer.querySelector('.token-bonus');\r\n        if (bonusToken) {\r\n            (_a = bonusToken.parentElement) === null || _a === void 0 ? void 0 : _a.classList.remove('scoring');\r\n        }\r\n    }\r\n    highlightTargetToken(index) {\r\n        const targetTokens = this.targetContainer.querySelectorAll('.target-token');\r\n        if (targetTokens[index]) {\r\n            targetTokens[index].classList.add('scoring');\r\n        }\r\n    }\r\n    removeTargetTokenHighlight(index) {\r\n        const targetTokens = this.targetContainer.querySelectorAll('.target-token');\r\n        if (targetTokens[index]) {\r\n            targetTokens[index].classList.remove('scoring');\r\n            targetTokens[index].classList.remove('skipped');\r\n        }\r\n    }\r\n    showTargetSkipIndicator(index) {\r\n        const targetTokens = this.targetContainer.querySelectorAll('.target-token');\r\n        if (targetTokens[index]) {\r\n            targetTokens[index].classList.remove('scoring');\r\n            targetTokens[index].classList.add('skipped');\r\n        }\r\n    }\r\n    highlightBonusTargetToken() {\r\n        const bonusTarget = this.targetContainer.querySelector('.target-bonus');\r\n        if (bonusTarget) {\r\n            bonusTarget.classList.add('scoring');\r\n        }\r\n    }\r\n    removeBonusTargetHighlight() {\r\n        const bonusTarget = this.targetContainer.querySelector('.target-bonus');\r\n        if (bonusTarget) {\r\n            bonusTarget.classList.remove('scoring');\r\n        }\r\n    }\r\n    showBonusSkipIndicator() {\r\n        var _a;\r\n        const bonusToken = this.tokensContainer.querySelector('.token-bonus');\r\n        if (bonusToken) {\r\n            (_a = bonusToken.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('skipped');\r\n        }\r\n    }\r\n    removeBonusSkipIndicator() {\r\n        var _a;\r\n        const bonusToken = this.tokensContainer.querySelector('.token-bonus');\r\n        if (bonusToken) {\r\n            (_a = bonusToken.parentElement) === null || _a === void 0 ? void 0 : _a.classList.remove('skipped');\r\n        }\r\n    }\r\n    showBonusTargetSkipIndicator() {\r\n        const bonusTarget = this.targetContainer.querySelector('.target-bonus');\r\n        if (bonusTarget) {\r\n            bonusTarget.classList.add('skipped');\r\n        }\r\n    }\r\n    removeBonusTargetSkipIndicator() {\r\n        const bonusTarget = this.targetContainer.querySelector('.target-bonus');\r\n        if (bonusTarget) {\r\n            bonusTarget.classList.remove('skipped');\r\n        }\r\n    }\r\n    showSkipIndicator(index) {\r\n        const tokenWrappers = this.tokensContainer.querySelectorAll('.token-wrapper');\r\n        if (tokenWrappers[index]) {\r\n            tokenWrappers[index].classList.remove('scoring');\r\n            tokenWrappers[index].classList.add('skipped');\r\n        }\r\n    }\r\n    animateScoreIncrement(from, to, tokenIndex = 0) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const duration = 600;\r\n            const steps = 20;\r\n            const increment = (to - from) / steps;\r\n            const stepDuration = duration / steps;\r\n            // Base pitch increases with token index\r\n            const basePitch = 800 + (tokenIndex * 250);\r\n            for (let i = 0; i <= steps; i++) {\r\n                const currentScore = Math.round(from + (increment * i));\r\n                this.scoreElement.textContent = `Score: ${currentScore}`;\r\n                this.scoreElement.classList.add('score-pulse');\r\n                // Play a quick tick sound every few steps, with pitch matching the token's pitch\r\n                if (i % 4 === 0 && i < steps) {\r\n                    this.playScoreSound(basePitch + (i * 20), 0.03);\r\n                }\r\n                yield this.delay(stepDuration);\r\n                this.scoreElement.classList.remove('score-pulse');\r\n            }\r\n        });\r\n    }\r\n    delay(ms) {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n}\r\nexports.GameRenderer = GameRenderer;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Check if module exists (development only)\n\tif (__webpack_modules__[moduleId] === undefined) {\n\t\tvar e = new Error(\"Cannot find module '\" + moduleId + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\r\n// This file serves as the entry point for the client-side application. It initializes the game engine and starts the game.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst engine_1 = require(\"./game/engine\");\r\n// Handle start screen and game initialization\r\nfunction initializeGame() {\r\n    const startScreen = document.getElementById('start-screen');\r\n    const startButton = document.getElementById('start-button');\r\n    const gameContainer = document.getElementById('game-container');\r\n    if (!startButton || !startScreen || !gameContainer) {\r\n        // If elements not found, start game immediately\r\n        const game = new engine_1.GameEngine();\r\n        game.start();\r\n        return;\r\n    }\r\n    // Start button click handler\r\n    startButton.addEventListener('click', () => {\r\n        // Hide start screen\r\n        startScreen.classList.add('hidden');\r\n        // Show game container\r\n        gameContainer.classList.remove('hidden');\r\n        // Initialize and start the game\r\n        const game = new engine_1.GameEngine();\r\n        game.start();\r\n    });\r\n}\r\n// Initialize when DOM is ready\r\ninitializeGame();\r\n"],"names":[],"ignoreList":[],"sourceRoot":""}